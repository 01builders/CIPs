| cip | XX (assigned by Editors) |
| - | - |
| title | Dynamic Fee Burn Adjustment |
| description | Introduces an adaptive mechanism to dynamically adjust the percentage of transaction fees that are burned or distributed to validators based on network utilization and staking security budget. |
| author | Marko Baricevic ([@tac0turtle](https://github.com/tac0turtle)) & Dean  ([@decanus](https://github.com/decanus)) |
| discussions-to | https://github.com/celestiaorg/CIPs/discussions/ |
| status | Draft |
| type | Standards Track |
| category | Core |
| created | 2025-10-30 |

## Abstract

This proposal introduces a dynamic mechanism to determine how Celestia handles transaction fees — specifically, how much is burned versus distributed to validators. The system automatically adjusts the burn ratio based on on-chain indicators such as block utilization and staking APR, aligning monetary policy with network security and usage demand.

## Motivation

Celestia currently collects transaction fees for blobspace usage, but their distribution by protocol design parameters rather than adaptive logic. As Celestia’s fee market evolves and issuance declines, a static approach may underpay validators during low activity or fail to manage inflation during high demand.

This proposal introduces an adaptive fee burn model to:
- Sustain validator rewards when fee revenue is low.
- Introduce deflationary pressure during periods of high utilization.
- Align token supply dynamics with economic security needs.

## Specification

### Overview

The protocol SHALL dynamically calculate the **burn percentage (B)** for each block using:
- **Block utilization (U):** used blobspace relative to target capacity.
- **Staking APR deviation (ΔAPR):** difference between actual and target staking return.

The burn ratio determines how total fees (F) are split:
- `Burn = F * B`
- `ValidatorReward = F * (1 - B)`

### Formula

Inputs:
U = used_blobspace / target_blobspace
APR_actual = (issuance_rewards + fee_rewards) / total_stake
APR_target = parameter (e.g., 8%)

Burn Ratio:
B = clamp(Bmin, Bbase + α * (U - 1.0) + β * (APR_actual - APR_target), Bmax)

Output:
Burn = F * B
ValidatorReward = F * (1 - B)

Where:
- `clamp(x, min, max)` constrains the result.
- α and β are responsiveness coefficients.
- Suggested defaults:
  - Bbase = 0.3
  - Bmin = 0.1
  - Bmax = 0.9
  - α = 0.5
  - β = 0.25

### Operation

1. Each block, the node computes `U` and `APR_actual` from on-chain data.
2. The formula outputs `B`, determining what portion of collected fees is burned.
3. Burned fees are sent to the null address; the rest are distributed to validators.

This system is deterministic and consensus-valid, with no off-chain dependencies.


## Parameters

| Parameter | Proposed value | Description | Changeable via Governance |
|------------|----------------|-------------|---------------------------|
| base_burn | 0.3 | Baseline burn fraction | Yes |
| burn_min | 0.1 | Minimum burn fraction | Yes |
| burn_max | 0.9 | Maximum burn fraction | Yes |
| alpha | 0.5 | Responsiveness to block utilization | Yes |
| beta | 0.25 | Responsiveness to APR deviation | Yes |
| apr_target | 0.08 | Target annualized staking APR | Yes |


## Rationale

Static burn ratios are inflexible. When network activity is low, validators can be undercompensated; when activity spikes, fixed burns miss the opportunity to reduce inflation.

The proposed model introduces feedback loops similar in spirit to EIP-1559 but extends them to consider validator security and network economics.

Alternative approaches considered:
- **Fixed split (e.g., 50% burn):** simple but non-responsive.
- **Governance-controlled slider:** flexible but too slow to adapt to market conditions.
- **Pure utilization-based:** ignores validator APR and can threaten security during quiet periods.

The hybrid approach provides responsive, transparent, and sustainable economic tuning.


## Backwards Compatibility

No backward compatibility issues found.
The proposal modifies how fees are *distributed* but not how they are *collected*.


## Test Cases

| Scenario | Input | Expected Burn % | Notes |
|-----------|--------|-----------------|-------|
| Low usage, low APR | U=0.5, APR_actual=0.05 | ~20% | Increases validator revenue |
| High usage, target APR | U=1.2, APR_actual=0.08 | ~60% | Balances inflation and rewards |
| High usage, high APR | U=1.3, APR_actual=0.10 | ~75–80% | Strong burn during rich conditions |
| Idle network | U=0.2, APR_actual=0.04 | 10% (floor) | Prevents underpayment starvation |


## Reference Implementation

Reference pseudocode (for module `x/feemarket/keeper.go`):

```go
func CalculateDynamicBurn(utilization, aprActual, aprTarget float64) float64 {
    Bbase, Bmin, Bmax := 0.3, 0.1, 0.9
    alpha, beta := 0.5, 0.25
    B := Bbase + alpha*(utilization-1.0) + beta*(aprActual-aprTarget)
    return Clamp(B, Bmin, Bmax)
}
````

## Security Considerations
	•	Determinism: All nodes derive identical values from shared on-chain data.
	•	Manipulation resistance: Both utilization and APR are consensus variables.
	•	Economic stability: Bounded α/β values prevent volatility or oscillations.
	•	Validator alignment: Ensures economic security scales with network demand, reducing incentives for off-chain side payments.
